/**
\page lua_api_game Game

\tableofcontents

This module provides a datatype "game" that represents a savegame.

\section lua_api_game_overview Overview

\subsection lua_api_game_overview_save Saved data

On a game object, you can access and modify everything that is saved.
The data saved and restored by the engine are the following:
- starting location of the player (map and destination on this map),
- life (maximum and current),
- money (maximum and current),
- magic (maximum and current),
- built-in ability levels (like attacking, swimming, running, etc.).
- possession state of each saved equipment item,
- equipment item assigned to each item command slot,
- keyboard and joypad associations to game commands,
- any key-value pair that you need to store for your quest (see
  \ref lua_api_game_get_value "game:get_value()" and
  \ref lua_api_game_set_value "game:set_value()").

When a game is running, more features are available
(like pausing the game, handling game commands, etc.).
Only one game can be running at a time.

\subsection lua_api_game_overview_commands Game commands

An important concept that comes with the game is the notion of
game commands.
Game commands are built-in game actions that can be mapped to a
low-level keyboard or joypad input.
They can be seen as an abstraction of the keyboard and the joypad.
Game commands are like a virtual game device that provides
the the following buttons:
- \c "action": Contextual action such as talking, swimming, throwing, etc.
- \c "attack": Main attack (using the sword).
- \c "pause": Pausing or unpausing the game.
- \c "item_1": Using the equipment item placed in slot 1 (see \ref
  lua_api_game_get_item_assigned "game:get_item_assigned()")
- \c "item_2": Using the equipment item placed in slot 2 (see \ref
  lua_api_game_get_item_assigned "game:get_item_assigned()")
- \c "right": Moving to the right.
- \c "left": Moving to the left.
- \c "up": Moving to the top.
- \c "down": Moving to the bottom.

Of course, these virtual commands are mapped to real, low-level inputs from
the keyboard and/or the joypad.
You script can control which keyboard and joypad inputs are associated to
each game command.

When a game command is pressed,
no matter if the command came from the keyboard or the joypad,
the engine performs some built-in behavior by
default (like pausing the game or moving the hero to the right).
But you can also extend or override this behavior,
because the engine notifies you first
(see \ref lua_api_game_on_command_pressed "game:on_command_pressed()").
Therefore, you usually don't have to worry about the underlying keyboard or
joypad input (but if you want to, you can, and the callbacks are exactly the
sames as in \ref
lua_api_main "sol.main" and in \ref lua_api_menu "menus").

\subsection lua_api_game_overview_table Accessing the game like tables

Objects of the game type are userdata, but like most Solarus
Lua types, they can also be accessed like tables.
This is especially useful for the game type to add, next to the built-in
game features, your own quest-specific functions and data (like your HUD and
your pause menu).

\section lua_api_game_functions Functions of sol.game

\subsection lua_api_game_exists sol.game.exists(file_name)

Returns whether the specified savegame file exists.

A valid quest write directory must be set (in your
\ref quest_properties_file "quest.dat file" or by
calling \ref lua_api_main_set_quest_write_dir "sol.main.set_quest_write_dir()"),
otherwise savegames cannot be used and this function generates a Lua error.
- \c file_name (string): Name of the file to test, relative
  to the \ref lua_api_main_get_quest_write_dir "quest write directory".
- Return value (boolean): \c true if there exists a file with this name
  in the quest write directory.

\subsection lua_api_game_delete sol.game.delete(file_name)

Deletes a savegame file.

A valid quest write directory must be set (in your
\ref quest_properties_file "quest.dat" file or by
calling \ref lua_api_main_set_quest_write_dir "sol.main.set_quest_write_dir()"),
otherwise savegames cannot be used and this function generates a Lua error.
- \c file_name (string): Name of the file to delete, relative
  to the \ref lua_api_main_get_quest_write_dir "quest write directory".

\subsection lua_api_game_load sol.game.load(file_name)

Loads an existing savegame, or initializes a new one if it does not exist
(but does not save it).

A valid quest write directory must be set (in your
\ref quest_properties_file "quest.dat" file or by
calling \ref lua_api_main_set_quest_write_dir "sol.main.set_quest_write_dir()"),
otherwise savegames cannot be used and this function generates a Lua error.
- \c file_name (string): Name of a savegame file, relative to the
  to the \ref lua_api_main_get_quest_write_dir "quest write directory".
- Return value (game): The loaded (or created) game.

\remark This function does not start the game, it just loads the savegame file
and initializes all \ref lua_api_item "equipment item scripts".
Then you can access the data saved in the savegame file and use the API of
equipment items.
To actually run the game, call \ref lua_api_game_start.

\section lua_api_game_methods Methods of the type game

\subsection lua_api_game_save game:save()

Saves this game into its savegame file.

A valid quest write directory must be set (in your
\ref quest_properties_file "quest.dat file" or by
calling \ref lua_api_main_set_quest_write_dir "sol.main.set_quest_write_dir()"),
otherwise savegames cannot be used and this function generates a Lua error.

\subsection lua_api_game_start game:start()

Runs this game.

This function is typically called from your savegame menu, when the player
chooses its savegame file.

If another game was running, it is stopped automatically because only one game
can be running at a time.

You can also call this function to restart the current game itself,
even if it was not saved recently (saved data will not be reset).
This may be useful to restart the game after the
\ref lua_api_game_on_game_over_started "game-over sequence".

\subsection lua_api_game_is_started game:is_started()

Returns whether this game is currently running.

Only one game can be running at a time.
- Return value (boolean): \c true if this game is running.

\subsection lua_api_game_is_suspended game:is_suspended()

Returns whether this game is currently suspended.

The game is suspended when at least one of the following conditions is true:
- the game is \ref lua_api_game_is_paused "paused",
- or a \ref lua_api_game_is_dialog_enabled "dialog" is active,
- or the \ref lua_api_game_is_game_over_enabled "game-over sequence" is active,
- or a transition between two maps is playing,
- or you explicitly called
  \ref lua_api_game_set_suspended "game:set_suspended(true)".

&nbsp;

- Return value (boolean): \c true if this game is currently suspended.
  Only possible when the game is running.

\subsection lua_api_game_set_suspended game:set_suspended([suspended])

Suspends or unsuspends the game.

Note that the game is also automatically suspended by the engine in the
following situations:
- when the game is \ref lua_api_game_is_paused "paused",
- or when a \ref lua_api_game_is_dialog_enabled "dialog" is active,
- or when the \ref lua_api_game_is_game_over_enabled "game-over sequence" is
  active,
- or when a transition between two maps is playing.

Therefore, if you call
\c game:set_suspended(false) during one of these sequences,
it will only take effect at the end of it.
- \c suspended (boolean, optional): \c true to suspend the game,
  \c false to resume it.
  No value means \c true.

\note When the hero goes to another map, the game is automatically
  unsuspended after the map opening transition.

\subsection lua_api_game_is_paused game:is_paused()

Returns whether this game is currently paused.
- Return value (boolean): \c true if this game is paused.
  Only possible when the game is running.

\subsection lua_api_game_set_paused game:set_paused([paused])

Pauses or resumes the game explictly.

Note that by default, a built-in game command already exists to pause and
unpause the game.
- \c paused (boolean, optional): \c true to pause the game, \c false to unpause it.
  Only possible when the game is running. No value means \c true.

\subsection lua_api_map_is_pause_allowed game:is_pause_allowed()

Returns whether the player can pause or unpause the \ref lua_api_game "game".
- Return value (boolean): \c true if the player is allowed to pause the game.

\subsection lua_api_map_set_pause_allowed game:set_pause_allowed([pause_allowed])

Sets whether the player can pause or unpause the \ref lua_api_game "game".
- \c pause_allowed (boolean, optional): \c true to allow the player to pause the
  game. No value means \c true.

\remark This function applies to the built-in \ref
  lua_api_game_overview_commands "pause command".
  Your script can still pause the game explicitly by calling
  \ref lua_api_game_set_paused "game:set_paused()".

\subsection lua_api_game_is_dialog_enabled game:is_dialog_enabled()

Returns whether this game is currently showing a dialog.

It does not matter whether the dialog is shown with the built-in,
minimal dialog box or with your custom dialog box
(see \ref lua_api_game_on_dialog_started "game:on_dialog_started()").

Only possible when the game is running.
- Return value (boolean): \c true if a dialog is being shown.

\subsection lua_api_game_start_dialog game:start_dialog(dialog_id, [info], [callback])

Starts showing a dialog.

A dialog must not be already active.
This function returns immediately, but you can provide a callback that will
be executed when the dialog finishes.
The game is suspended during the dialog, like when it is paused.

If the event
\ref lua_api_game_on_dialog_started "game:on_dialog_started()"
is not defined, then the engine will show a default, minimal dialog system
without decoration.
The user will be able to close the dialog by pressing
the action command
(you don't need to call
\ref lua_api_game_stop_dialog "game:stop_dialog()").

On the contrary, if the event
\ref lua_api_game_on_dialog_started "game:on_dialog_started()"
is defined, the engine calls it and does nothing else.
This is the recommended way, because you can make your custom dialog box
implementation with any feature you need.
The game will be suspended until you call
\ref lua_api_game_stop_dialog "game:stop_dialog()" explicitly.
- \c dialog_id (string): Id of the dialog to show.
  The corresponding dialog must exist in the
  \ref quest_language_dialogs "dialogs.dat"
  file of the current
  \ref lua_api_language "language".
- \c info (any type, optional): Any
  information you want to pass to the
  \ref lua_api_game_on_dialog_started "game:on_dialog_started()" event.
  You can use this parameter to include in the dialog any information that is
  only known at runtime, for example the name of the player, the best score of
  a mini-game or the time spent so far in the game. See the examples below.
- \c callback (function, optional): A function to be called when the dialog
  finishes. A status parameter (possibly \c nil)
  is passed to your function: its value is the argument of
  \ref lua_api_game_stop_dialog "game:stop_dialog()" and it represents
  the result of the dialog.
  This feature may be used by your dialog box system to return any useful
  information to the map script, like the answer chosen by the player if the
  dialog was a question, or whether the dialog was skipped.

Example of a small map script with an NPC that shows a simple dialog:
\verbatim
local map = ...

function some_npc:on_interaction()
  -- Remember that you specify a dialog id, not directly the text to show.
  -- The text is defined in the dialogs.dat file of the current language.
  map:get_game():start_dialog("welcome_to_my_house")
end
\endverbatim

Here is a more complex example, with an NPC that asks a question.
This example assumes that your dialog box system can ask questions to the
player, and returns the answer as a boolean value passed to
\ref lua_api_game_stop_dialog "game:stop_dialog()".
\verbatim
local map = ...
local game = map:get_game()
function another_npc:on_interaction()
  game:start_dialog("give_me_100_rupees_please", function(answer)
    if answer then
      if game:get_money() >= 100 then
        game:remove_money(100)
        game:start_dialog("thanks")
      else
        sol.audio.play_sound("wrong")
        game:start_dialog("not_enough_money")
      end
    else
      game:start_dialog("not_happy")
    end
  end)
end
\endverbatim

Finally, to illustrate the use of the \c info parameter, let's modify the
previous example to make the amount of money only determined at runtime.
In other words, we want an NPC that can say "Please give me 100 rupees",
but also "Please give me 25 rupees" or any number.
Since the number is only known at runtime, it can no longer be hardcoded
in the text of the
\ref quest_language_dialogs "dialog".
So let's assume that the text of the dialog contains instead a special
sequence (like \c "$v") to be substituted by the final value.
(Note that \ref lua_api_shop_treasure_dialogs "shop treasures" use a very similar
convention for their dialogs.)
\verbatim
local map = ...
local game = map:get_game()

function another_npc:on_interaction()
  local how_much = math.random(100)
  game:start_dialog("give_me_x_rupees_please", how_much, function(answer)
    if answer then
      if game:get_money() >= how_much then
        game:remove_money(how_much)
        -- ... The rest is unchanged.
\endverbatim
To make this example work, you need a dialog box system
that
performs the substitution when \c info is set.
See \ref lua_api_game_on_dialog_started "game:on_dialog_started()".

\note The \c info parameter of
  \ref lua_api_game_start_dialog "game:start_dialog()"
  and the status parameter of the callback
  are a flexible way to make the map script communicate with the dialog
  box system in both directions.
  They can been seen as the parameter and the result (respectively)
  of the dialog being displayed.
  They can both be any value, like a table with many information.

\subsection lua_api_game_stop_dialog game:stop_dialog([status])

Stops the current dialog.

A dialog must be active when you call this function.
The dialog stops being displayed and the game can resume.
This function is typically called by your dialog box system when it
wants to close the dialog.

The
\ref lua_api_game_on_dialog_finished "game:on_dialog_finished()"
event is first called (if it is defined).
Then, the callback that was passed to
\ref lua_api_game_start_dialog "game:start_dialog()"
is called (if it was defined)
with the \c status argument.
- \c status (any type, optional): Some information to return to the
  script that started the dialog.
  For example, you can pass the result of the dialog if it was a question,
  or whether it was skipped by the user before the end.
  See the
  \ref lua_api_game_start_dialog "examples above".

\subsection lua_api_game_is_game_over_enabled game:is_game_over_enabled()

Returns whether this game is currently showing a game-over sequence.

Only possible when the game is running.

The game-over sequence automatically starts when the player's life
gets to zero, or when you call
\ref lua_api_game_start_game_over "game:start_game_over()" explicitly.
Define the event
\ref lua_api_game_on_game_over_started "game:on_game_over_started()"
to show your game-over menu.
If you don't define this event, by default, there is no game-over sequence
and the engine immediately restarts the game (but does not save it).
- Return value (boolean): \c true if a game-over sequence is running.

\subsection lua_api_game_start_game_over game:start_game_over()

Starts the game-over sequence manually.

Only possible when the game is running.

This function is seldom needed since the game-over sequence
automatically starts when the player's life reaches zero.
But you can use it if you want to start a game-over sequence even
when the player's life is greater than zero.

\subsection lua_api_game_stop_game_over game:stop_game_over()

Finishes the current game-over sequence.

Only possible during a game-over sequence.

The game is suspended during the whole game-over sequence.
Call this function to resume it.
If the
\ref lua_api_game_get_life "life"
is still zero at this point, then the engine automatically restores
full life.

\subsection lua_api_game_get_map game:get_map()

Returns the current map.
- Return value (\ref lua_api_map "map"): The current map of this game
  (\c nil if this game is not running).

\subsection lua_api_game_get_hero game:get_hero()

Returns the
\ref lua_api_hero "hero".

The hero is a \ref lua_api_entity "map entity" that always exists
while the game is running, and that persists when the map changes.
For this reason, he can be seen as belonging to the game more than to the
current map. That's why this function exists.
- Return value (\ref lua_api_hero "hero"): The hero, or \c nil if the game
  is not running.

\remark Equivalent to <tt>game:get_map():get_entity("hero")</tt>.

\subsection lua_api_game_get_value game:get_value(savegame_variable)

Returns a value saved.
- \c savegame_variable (string): Name of the value to get from the savegame.
- Return value (string, number or boolean): The corresponding value
  (\c nil if no value is defined with this key).

\subsection lua_api_game_set_value game:set_value(savegame_variable, value)

Sets a value in the savegame.

This function allows to store key-value pairs in the savegame.
Values can be strings, integers or booleans.
- \c savegame_variable (string): Name of the value to save (must contain
  alphanumeric characters or \c '_' only, and must start with a letter).
- \c value (string, number or boolean): The value to set, or \c nil to unset
  this value.

\remark This method changes a value, but remember that the change will be
  saved in the savegame file only when you call
  \ref lua_api_game_save "game:save()".

\subsection lua_api_game_get_starting_location game:get_starting_location()

Returns the location where the hero is placed when this game is started or
restarted.
- Return value 1 (string): Id of the starting map.
  \c nil means that it was not set: in this case, the first map declared in
  \ref quest_database_file "project_db.dat" will be used.
- Return value 2 (string): Name of the destination where the hero will be
  placed on that map.
  \c nil means that it was not set: in this case, the default destination
  entity of that map will be used.

\subsection lua_api_game_set_starting_location game:set_starting_location([map_id, [destination_name]])

Sets the location where the hero should be placed when this game is started or
restarted.
- \c map_id (string, optional): Id of the starting map. By default, the first
  map declared in
  \ref quest_database_file "project_db.dat" is used.
- \c destination_name (string, optional): Name of the destination where the hero should
  be placed on that map. By default, the default destination of the map is used.

\remark When the hero moves from a map to another map that belongs to a
  different world (for example, from a dungeon to the outside world) using a
  destination entity, by default, the starting location is automatically set
  to this point.
  If this behavior is okay for your quest, you never need to call this function
  except the first time: when initializing a new savegame file.
  This behavior can be changed by setting the "Save starting location"
  property of destinations, from the quest editor or from a script
  (with
  \ref lua_api_destination_set_starting_location_mode
  "destination:set_starting_location_mode()").

\subsection lua_api_game_get_life game:get_life()

Returns the current level of life of the player.
- Return value (number): The current life.

\subsection lua_api_game_set_life game:set_life(life)

Sets the level of life of the player.

A negative value will be replaced by zero.
A value greater than
than the maximum level of life will be replaced by the maximum value.
- \c life (number): Number of life points to set.

\subsection lua_api_game_add_life game:add_life(life)

Adds some life to the player.
- \c life (number): Number of life points to add.
  Must be a positive number or \c 0.

\remark Equivalent to <tt>game:set_life(game:get_life() + life)</tt>.

\subsection lua_api_game_remove_life game:remove_life(life)

Removes some life from the player.
- \c life (number): Number of life points to remove.
  Must be a positive number or \c 0.

\remark Equivalent to <tt>game:set_life(game:get_life() - life)</tt>.

\subsection lua_api_game_get_max_life game:get_max_life()

Returns the maximum level of life of the player.
- Return value (number): The maximum number of life points.

\subsection lua_api_game_set_max_life game:set_max_life(life)

Sets the maximum level of life of the player.
- \c life (number): Maximum number of life points to set.
  Must be a positive number.

\subsection lua_api_game_add_max_life game:add_max_life(life)

Increases the maximum level of life of the player.
- \c life (number): Maximum number of life points to add to the maximum.
  Must be a positive number or \c 0.

\remark Equivalent to <tt>game:set_max_life(game:get_max_life() + life)</tt>.

\subsection lua_api_game_get_money game:get_money()

Returns the amount of money of the player.
- Return value (number): The current amount of money.

\subsection lua_api_game_set_money game:set_money(money)

Sets the amount of money of the player.

A negative value will be replaced by zero.
A value greater than
than the maximum amount of money will be replaced by the maximum amount.
- \c money (number): The amount of money to set.

\subsection lua_api_game_add_money game:add_money(money)

Adds some money to the player.
- \c money (number): Amount of money to add.
  Must be a positive number or \c 0.

\remark Equivalent to <tt>game:set_money(game:get_money() + money)</tt>.

\subsection lua_api_game_remove_money game:remove_money(money)

Removes some money from the player.
- \c money (number): Amount of money to remove.
  Must be a positive number or \c 0.

\remark Equivalent to <tt>game:set_money(game:get_money() - money)</tt>.

\subsection lua_api_game_get_max_money game:get_max_money()

Returns the maximum amount of money of the player.
- Return value (number): The maximum money.

\subsection lua_api_game_set_max_money game:set_max_money(money)

Sets the maximum amount of money of the player.
- \c money (number): Maximum money to set.
  Must be a positive number or \c 0.

\subsection lua_api_game_get_magic game:get_magic()

Returns the current number of magic points.
- Return value (number): The current number of magic points.

\subsection lua_api_game_set_magic game:set_magic(magic)

Sets the amount of magic points of the player.

A negative value will be replaced by zero.
A value greater than
than the maximum number of magic points will be replaced by that maximum.
- \c magic (number): The number of magic points to set.

\subsection lua_api_game_add_magic game:add_magic(magic)

Adds some magic points to the player.
- \c magic (number): Number of magic points to add.
  Must be a positive number or \c 0.

\remark Equivalent to <tt>game:set_magic(game:get_magic() + magic)</tt>.

\subsection lua_api_game_remove_magic game:remove_magic(magic)

Removes some magic points from the player.
- \c magic (number): Number of magic points to remove.
  Must be a positive number or \c 0.

\remark Equivalent to <tt>game:set_magic(game:get_magic() - magic)</tt>.

\subsection lua_api_game_get_max_magic game:get_max_magic()

Returns the maximum number of magic points.
- Return value (number): The maximum number of magic points.

\subsection lua_api_game_set_max_magic game:set_max_magic(magic)

Sets the maximum number of magic points.
- \c magic (number): The maximum number of magic points to set.
  Must be a positive number or \c 0.

\subsection lua_api_game_has_ability game:has_ability(ability_name)

Returns whether the player has a built-in ability.
- \c ability_name: Name of the ability to get (see \ref
  lua_api_game_get_ability "game:get_ability()" for the list of
  valid ability names).
- Return value (boolean): \c true if the player has this ability.

\remark Equivalent to <tt>game:get_ability(ability_name) > 0</tt>.

\subsection lua_api_game_get_ability game:get_ability(ability_name)

Returns the level of a built-in ability.

Built-in ability levels indicate whether the hero can perform some built-in
actions like attacking, swimming or running.
The initial value is \c 0 unless specified otherwise.
- \c ability_name (string): Name of the ability to get.
  Valid ability names are:
  - \c "sword": Using the sword when pressing the action command.
    Determines the default sword sprite.
  - \c "sword_knowledge": Ability to make the super spin-attack.
  - \c "tunic": Resistance level that reduces the damage received by the hero.
    Determines the default sprite used for the hero's body.
    The initial value is \c 1.
  - \c "shield": Protection against enemies.
    Allows to avoid some attacks.
    Determines the default shield sprite.
  - \c "lift": Ability to lift heavy
    \ref lua_api_destructible "destructible objects".
  - \c "swim": Ability to swim in deep water.
  - \c "jump_over_water": Automatically jumping when arriving into
    water without the \c "swim" ability.
  - \c "run": Running when pressing the action command.
  - \c "push": Trying to push when walking towards an obstacle.
    The initial value is \c 1.
  - \c "grab": Grabbing the faced obstacle when pressing the action command.
    The initial value is \c 1.
  - \c "pull": Pulling the faced obstacle the hero is grabbing.
    The initial value is \c 1.
  - \c "detect_weak_walls": Notifying the player with a sound when a weak wall
    is nearby.
- Return value (number): Level of this ability
  (\c 0 means not having this ability yet).

\subsection lua_api_game_set_ability game:set_ability(ability_name, level)

Sets the level of an ability.
- \c ability_name (string): Name of the ability to set (see \ref
  lua_api_game_get_ability "game:get_ability()" for the list of
  valid ability names).
- \c level (number): Level of this ability to set (\c 0 removes the ability).

\subsection lua_api_game_get_item game:get_item(item_name)

Returns an equipment item.
- \c item_name (string): Name of the item to get.
- Return value (\ref lua_api_item "item"): The corresponding equipment item.

\subsection lua_api_game_has_item game:has_item(item_name)

Returns whether the player has the specified
\ref lua_api_item "equipment item"
(only for a saved item).
- \c item_name (string): Name of the item to check.
- Return value (boolean): \c true if the player has at least the first variant
  of this item.

\remark Equivalent to <tt>game:get_item(item_name):get_variant() > 0</tt>.

\subsection lua_api_game_get_item_assigned game:get_item_assigned(slot)

Returns the equipment item assigned to a slot.
- \c slot (number): The slot to get (\c 1 or \c 2).
- Return value (\ref lua_api_item "item"): The equipment item associated to
this slot (\c nil means none).

\subsection lua_api_game_set_item_assigned game:set_item_assigned(slot, item)

Assigns an equipment item to a slot.
- \c slot (number): The slot to set (\c 1 or \c 2).
- \c item (\ref lua_api_item "item"): The equipment item to associate to this
  slot, or \c nil to make the slot empty.

\subsection lua_api_game_get_command_effect game:get_command_effect(command)

Returns the current built-in effect of a game command.

This function is useful if you want to show a HUD that indicates to the player
the current
effect of pressing a game command, especially for command \c "action" whose
effect changes a lot depending on the context.
- \c command (string): Name of a game command.
  Valid commands are
  \c "action", \c "attack", \c "pause", \c "item_1", \c "item_2",
  \c "right", \c "up", \c "left" and \c "down".
- Return value (string): A string describing the current built-in effect of
  this game command. \c nil means that this command has currently no built-in
  effect (for example because the game is paused). Possible values are:
  - For command \c "action": \c "next", \c "look", \c "open",
    \c "lift", \c "throw", \c "grab", \c "speak", \c "swim", \c "run" or \c nil.
  - For command \c "attack": \c "sword" or \c nil.
  - For command \c "pause": \c "pause", \c "return" or \c nil.
  - For command \c "item_1": \c "use_item_1" or \c nil.
  - For command \c "item_2": \c "use_item_2" or \c nil.
  - For command \c "right": \c "move_right" or \c nil.
  - For command \c "left": \c "move_left" or \c nil.
  - For command \c "up": \c "move_up" or \c nil.
  - For command \c "down": \c "move_down" or \c nil.

\remark All these built-in game commands are initially mapped to some default
keyboard and joypad inputs. You can use
\ref lua_api_game_set_command_keyboard_binding "game:set_command_keyboard_binding()",
\ref lua_api_game_set_command_joypad_binding "game:set_command_joypad_binding()"
and
\ref lua_api_game_capture_command_binding "game:capture_command_binding()"
to change or even disable these mappings.

\remark It is also possible to override the behavior of game commands by
intercepting the events
\ref lua_api_game_on_command_pressed "game:on_command_pressed()"
\ref lua_api_game_on_command_released "game:on_command_released()".

\subsection lua_api_game_get_command_keyboard_binding game:get_command_keyboard_binding(command)

Returns the keyboard key that triggers the specified game command.
- \c command (string): Name of a game command.
  Valid commands are
  \c "action", \c "attack", \c "pause", \c "item_1", \c "item_2",
  \c "right", \c "up", \c "left" and \c "down".
- Return value (string): Name of the keyboard key that triggers this game
  command, or \c nil if no keyboard key is mapped to this game command.

\subsection lua_api_game_set_command_keyboard_binding game:set_command_keyboard_binding(command, key)

Sets the keyboard key that triggers a game command.
- \c command (string): Name of a game command.
  Valid commands are
  \c "action", \c "attack", \c "pause", \c "item_1", \c "item_2",
  \c "right", \c "up", \c "left" and \c "down".
- key (string): Name of the keyboard key that should trigger this game
  command (\c nil means none).

\note If this keyboard key was already mapped to a command, keyboard keys of
both commands are switched.

\subsection lua_api_game_get_command_joypad_binding game:get_command_joypad_binding(command)

Returns the joypad input that triggers the specified game command.
- \c command (string): Name of a game command.
  Valid commands are
  \c "action", \c "attack", \c "pause", \c "item_1", \c "item_2",
  \c "right", \c "up", \c "left" and \c "down".
- Return value (string): A string describing what joypad input triggers this
  game command, or \c nil if no joypad input is mapped to this game command.
  This string can have one of the following forms:
  - <tt>"button X"</tt> where X is the index of a joypad button (first is \c 0),
  - <tt>"axis X +"</tt> where X is the index of a joypad axis (first is \c 0),
  - <tt>"axis X -"</tt> where X is the index of a joypad axis (first is \c 0),
  - <tt>"hat X Y"</tt> where X is the index of a joypad hat (first is \c 0)
  and Y is a direction (\c 0 to \c 7).

\subsection lua_api_game_set_command_joypad_binding game:set_command_joypad_binding(command, joypad_string)

Sets the joypad input that should trigger the specified game command.
- \c command (string): Name of a game command.
  Valid commands are
  \c "action", \c "attack", \c "pause", \c "item_1", \c "item_2",
  \c "right", \c "up", \c "left" and \c "down".
- joypad_string (string): A string describing what joypad input should trigger
  this game command (\c nil means none).
  This string must have one of the following forms:
  - <tt>"button X"</tt> where X is the index of a joypad button (first is \c 0),
  - <tt>"axis X +"</tt> where X is the index of a joypad axis (first is \c 0),
  - <tt>"axis X -"</tt> where X is the index of a joypad axis (first is \c 0),
  - <tt>"hat X Y"</tt> where X is the index of a joypad hat (first is \c 0)
    and Y is a direction (\c 0 to \c 7).

\note If this joypad input was already mapped to a command, joypad inputs of
both commands are switched.

\subsection lua_api_game_capture_command_binding game:capture_command_binding(command, [callback])

Makes the next keyboard or joypad input become the new binding for the
specified game command.

This function returns immediately. After you call it, the next time
the player presses a keyboard key or performs a joypad input,
this input is treated differently:
instead of being forwarded to your script or handled by the engine as usual,
it automatically becomes the new keyboard or joypad binding for a game command.
- \c command (string): Name of a game command.
  Valid commands are
  \c "action", \c "attack", \c "pause", \c "item_1", \c "item_2",
  \c "right", \c "up", \c "left" and \c "down".
- \c callback (function, optional): A function to call when the new input occurs.

\note If the keyboard (or joypad) input was already mapped to a command,
keyboard (or joypad) inputs of both commands are switched.

\subsection lua_api_game_is_command_pressed game:is_command_pressed(command)

Returns whether a built-in game command is currently pressed.
- \c command (string): Name of a game command.
  Valid commands are
  \c "action", \c "attack", \c "pause", \c "item_1", \c "item_2",
  \c "right", \c "up", \c "left" and \c "down".
- Return value (boolean): \c true if this game command is currently pressed by
  the player.

\subsection lua_api_game_get_commands_direction game:get_commands_direction()

Returns the direction (in an 8-direction system) formed by the combination
of directional game commands currently pressed by the player.
- Return value (number): The direction wanted by the player (\c 0 to 7),
  or \c nil for no direction. No direction means that no directional command
  is pressed, or that contradictory directional commands are pressed,
  like left and right at the same time (impossible with most joypads, but
  easy with a keyboard).

\remark This function is provided for convenience. Its result can also be
  computed by calling
  \ref lua_api_game_is_command_pressed "game:is_command_pressed()" four times
  (with the four directional game commands).

\subsection lua_api_game_simulate_command_pressed game:simulate_command_pressed(command)

Creates a command pressed input event.

Everything acts like if the player had just pressed an input mapped to this
game command.
- \c command (string): Name of a game command.
  Valid commands are
  \c "action", \c "attack", \c "pause", \c "item_1", \c "item_2",
  \c "right", \c "up", \c "left" and \c "down".

\subsection lua_api_game_simulate_command_released game:simulate_command_released(command)

Creates a command released input event.

Everything acts like if the player had just released an input mapped to this
game command.
- \c command (string): Name of a game command.
  Valid commands are
  \c "action", \c "attack", \c "pause", \c "item_1", \c "item_2",
  \c "right", \c "up", \c "left" and \c "down".

\section lua_api_game_events Events of a game

Events are callback methods automatically called by the engine if you define
them.
In the case of a game, they are only called on the game currently running, if
any.

\subsection lua_api_game_on_started game:on_started()

Called when this game starts running (including when you restart
the same game).

\subsection lua_api_game_on_finished game:on_finished()

Called when this game stops running (including when you restart
the same game).

\subsection lua_api_game_on_update game:on_update()

Called at each cycle of the main loop while this game is running.

\remark As this function is called at each cycle, it is recommended to use other
solutions when possible, like \ref lua_api_timer "timers" and other events.

\subsection lua_api_game_on_draw game:on_draw(dst_surface)

Called when the game has just been redrawn by the engine.

The engine has already drawn the current map, since the map is always drawn
before the game.
If the game has
\ref lua_api_menu "menus", these menu are not drawn yet at this point.
Use this event if you want to draw some additional content before the menus.
- \c dst_surface (\ref lua_api_surface "surface"): The surface where the game
  is drawn.

\subsection lua_api_game_on_map_changed game:on_map_changed(map)

Called when the player has just entered a map.

The new map is already started at this point.
For example, you may use this event if some parts of your HUD needs to be
changed on particular maps.
- \c map (\ref lua_api_map "map"): The new active map.

\remark This event is also called for the first map (when your game starts).

\subsection lua_api_game_on_paused game:on_paused()

Called when the game has just been paused.

The game may have been paused by the player (by pressing the \c "pause"
game command) or by you (by calling
\ref lua_api_game_set_paused "game:set_paused(true)").

This function is typically the place where you should start your pause menu.

\subsection lua_api_game_on_unpaused game:on_unpaused()

Called when the game is being resumed.

The game may have been unpaused by the player (by pressing the \c "pause"
game command) or by you (by calling
\ref lua_api_game_set_paused "game:set_paused(false)").

This is probably a good place to stop your pause menu.

\subsection lua_api_game_on_dialog_started game:on_dialog_started(dialog, [info])

Called when a dialog starts.

The dialog may be triggered by a Lua script
(by calling \ref lua_api_game_start_dialog "game:start_dialog()")
or by the engine in various situations (for example
when finding a treasure).

If this event is not defined, the engine shows a minimal dialog box without
decoration and you have nothing else to do.

If this event is defined, the engine does nothing and your script is
responsible to show the dialog in any way you want,
and to close it later by calling
\ref lua_api_game_stop_dialog "game:stop_dialog()".
It is recommended to implement your dialog system as a
\ref lua_api_menu "menu": if you do so,
you will automatically get called by the engine
when a command is pressed,
when you need to draw the dialog box on the screen, etc.
- \c dialog (table): All properties of the dialog to show.
  This table is identical to the one returned by
  \ref lua_api_language_get_dialog "sol.language.get_dialog()".
  It is a table with at least the following two entries:
  - \c dialog_id (string): Id of the dialog.
  - \c text (string): Text of the dialog in the current language.
    It may have several lines.
    When it is not empty, it always ends with a newline character.

  The table also contains all custom entries defined in
  \ref quest_language_dialogs "text/dialogs.dat"
  for this dialog.
  These custom entries always have string keys and string values.
  Values that were defined as numbers in \c "text/dialogs.dat" are replaced
  in this table by their string representation,
  and values that were defined as booleans are
  replaced by the string \c "1" for \c true and \c "0" for \c false.
- \c info (any value, optional): Some additional information for this
  particular dialog. You can get here some data that is only known at runtime.
  See the examples of \ref lua_api_game_start_dialog "game:start_dialog()".

\subsection lua_api_game_on_dialog_finished game:on_dialog_finished(dialog)

Called when the current dialog stops.
- \c dialog (table): All properties of the dialog that was shown.
  See \ref lua_api_game_on_dialog_started "game:on_dialog_started()"
  for a description of this table.

\subsection lua_api_game_on_game_over_started game:on_game_over_started()

Called when a game-over sequence starts.

This event is called when the player's life reaches zero,
as soon as the
\ref lua_api_hero "hero"
is in a state that allows game-over.
It is also called if you started a game-over sequence manually with
\ref lua_api_game_start_game_over "game:start_game_over()".

If this event is not defined, there is no game-over sequence:
the game restarts immediately, like if you called
\ref lua_api_game_start "game:start()",
and the full life of the player is restored.

If this event is defined, the engine does nothing except suspending the game.
Your script is then
responsible to show a game-over sequence in any way you want,
and to call
\ref lua_api_game_stop_game_over "game:stop_game_over()"
once you have finished.

For instance, you may create a
\ref lua_api_game_start_dialog "dialog"
that lets the player
\ref lua_api_game_start "restart the game"
or
\ref lua_api_game_save "save"
and
\ref lua_api_main_reset "quit",
or a
\ref lua_api_menu "menu"
with more options.

Actually, it is not even required to
restart or quit
the game after your game-over
sequence (even if this is the most common case).
Indeed, you can also just resume the game.
In this case, the game continues normally like if nothing happened.

\subsection lua_api_game_on_game_over_finished game:on_game_over_finished()

Called when the current game-over sequence stops.

This event is also called if you did not define a game-over sequence.

\subsection lua_api_game_on_key_pressed game:on_key_pressed(key, modifiers)

Called when the user presses a keyboard key while your game is running.
- \c key (string): Name of the raw key that was pressed.
- \c modifiers (table): A table whose keys indicate what modifiers were
  down during the event. Possible table keys are \c "shift", \c "control" and
  \c "alt". Table values don't matter.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.
  If you return \c false or nothing, the event will continue its propagation
  in this order: to the game \ref lua_api_menu "menus" if any,
  to the current map (including its own menus if any),
  and then to the game commands.

If you handle the event, you should return \c true to make the event stop
being propagated. The \ref lua_api_menu "menus"
of your game (if any) and the current map won't be not notified in this case.
On the contrary, if neither your game, its menus nor the current map handle
the event, then the engine handles it with a built-in behavior.
This built-in behavior is to check whether a game command is mapped to the
keyboard key that was pressed. If yes, the keyboard pressed event will
be transformed into a game command pressed event
(see \ref lua_api_game_on_command_pressed "game:on_command_pressed()").

\remark This event indicates the raw keyboard key pressed. If you want the
corresponding character instead (if any), see
\ref lua_api_game_on_character_pressed "game:on_character_pressed()".
If you want the corresponding higher-level game command (if any), see
\ref lua_api_game_on_command_pressed "game:on_command_pressed()".

\subsection lua_api_game_on_key_released game:on_key_released(key, modifiers)

Called when the user releases a keyboard key while your game is running.
- \c key (string): Name of the raw key that was released.
- \c modifiers (table): A table whose keys indicate what modifiers were
  down during the event. Possible table keys are \c "shift", \c "control" and
  \c "alt". Table values don't matter.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.
  If you return \c false or nothing, the event will continue its propagation
  in this order: to the game \ref lua_api_menu "menus" if any,
  to the current map (including its own menus if any),
  and then to the game commands.

If you handle the event, you should return \c true to make the event stop
being propagated. The \ref lua_api_menu "menus"
of your game (if any) and the current map won't be not notified in this case.
On the contrary, if neither your game, its menus nor the current map handle
the event, then the engine handles it with a built-in behavior.
This built-in behavior is to check whether a game command is mapped to the
keyboard key that was released. If yes, the "keyboard released" event will
be transformed into a "game command released" event
(see \ref lua_api_game_on_command_released "game:on_command_released()").

\subsection lua_api_game_on_character_pressed game:on_character_pressed(character)

Called when the user enters text
while your game is running.
- \c character (string): A utf-8 string representing the character that was
  entered.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.
  If you return \c false or nothing, the event will continue its propagation
  in this order: to the game \ref lua_api_menu "menus" if any
  and then to the current map (including its own menus if any).

\remark When a character key is pressed, two events are called:
\ref lua_api_game_on_key_pressed "game:on_key_pressed()"
(indicating the raw key)
and \ref lua_api_game_on_character_pressed "game:on_character_pressed()"
(indicating the utf-8 character).
If your game needs to input text from the user,
\ref lua_api_game_on_character_pressed "game:on_character_pressed()"
is what you want because it
considers the keyboard's layout and gives you international utf-8
strings.

\subsection lua_api_game_on_joypad_button_pressed game:on_joypad_button_pressed(button)

Called when the user presses a joypad button while your game is running.
- \c button (number): Index of the button that was pressed.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.

\subsection lua_api_game_on_joypad_button_released game:on_joypad_button_released(button)

Called when the user releases a joypad button while your game is running.
- \c button (number): Index of the button that was released.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.

\subsection lua_api_game_on_joypad_axis_moved game:on_joypad_axis_moved(axis, state)

Called when the user moves a joypad axis while your game is running.
- \c axis (number): Index of the axis that was moved. Usually, \c 0 is an
  horizontal axis and \c 1 is a vertical axis.
- \c state (number): The new state of the axis that was moved. \c -1 means
  left or up, \c 0 means centered and \c 1 means right or down.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.

\subsection lua_api_game_on_joypad_hat_moved game:on_joypad_hat_moved(hat, direction8)

Called when the user moves a joypad hat while your game is running.
- \c hat (number): Index of the hat that was moved.
- \c direction8 (number): The new direction of the hat. \c -1 means that the
  hat is centered. \c 0 to \c 7 indicates that the hat is in one of the eight
  main directions.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.

\subsection lua_api_game_on_command_pressed game:on_command_pressed(command)

Called when the player presses a game command
(a keyboard key or a joypad action mapped to a built-in game behavior)
while this game is running.
You can use this event to override the normal built-in behavior of the game command.
- \c command (string): Name of the built-in game command that was pressed.
  Possible commands are
  \c "action", \c "attack", \c "pause", \c "item_1", \c "item_2",
  \c "right", \c "up", \c "left" and \c "down".
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects
  (you are overriding the built-in behavior of pressing this game command).

\remark This event is not triggered if you already handled its underlying
  low-level keyboard or joypad event.

\subsection lua_api_game_on_command_released game:on_command_released(command)

Called when the player released a game command
(a keyboard key or a joypad action mapped to a built-in game behavior).
while this game is running.
You can use this event to override the normal built-in behavior of the game command.
- \c command (string): Name of the built-in game command that was released.
  Possible commands are
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects
  (you are overriding the built-in behavior of releasing this game command).

\remark This event is not triggered if you already handled its underlying
  low-level keyboard or joypad event.

\subsection lua_api_game_on_mouse_pressed game:on_mouse_pressed(button, x, y)

Called when the user presses a mouse button while the game is running.
- \c button (string): Name of the mouse button that was pressed.
  Possible values are \c "left", \c "middle", \c "right", \c "x1" and \c "x2".
- \c x (integer): The x position of the mouse in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- \c y (integer): The y position of the mouse in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.

\subsection lua_api_game_on_mouse_released game:on_mouse_released(button, x, y)

Called when the user releases a mouse button while the game is running.
- \c button (string): Name of the mouse button that was released.
  Possible values are \c "left", \c "middle", \c "right", \c "x1" and \c "x2".
- \c x (integer): The x position of the mouse in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- \c y (integer): The y position of the mouse in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.

\subsection lua_api_game_on_finger_pressed game:on_finger_pressed(finger, x, y, pressure)

Called when the user presses a finger while the game is running.
- \c finger (integer): ID of the finger that was pressed.
- \c x (integer): The x position of the finger in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- \c y (integer): The y position of the finger in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- \c pressure (number): The pressure of the finger, normalized between 0 and 1.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.

\subsection lua_api_game_on_finger_released game:on_finger_released(finger, x, y, pressure)

Called when the user releases a finger while the game is running.
- \c finger (integer): ID of the finger that was pressed.
- \c x (integer): The x position of the finger in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- \c y (integer): The y position of the finger in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- \c pressure (number): The pressure of the finger, normalized between 0 and 1.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.

\subsection lua_api_game_on_finger_moved game:on_finger_moved(finger, x, y, dx, dy, pressure)

Called when the user moves a finger while the game is running.
- \c finger (integer): ID of the finger that was pressed.
- \c x (integer): The x position of the finger in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- \c y (integer): The y position of the finger in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- \c dx (integer): The horizontal distance moved by finger in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- \c dy (integer):The vertical distance moved by finger in
  \ref lua_api_video_get_quest_size "quest size" coordinates.
- \c pressure (number): The pressure of the finger, normalized between 0 and 1.
- Return value (boolean): Indicates whether the event was handled. If you
  return \c true, the event won't be propagated to other objects.

*/

